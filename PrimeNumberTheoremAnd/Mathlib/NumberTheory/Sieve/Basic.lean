/-
Copyright (c) 2023 Arend Mellendijk. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Arend Mellendijk

! This file was ported from Lean 3 source module sieve
-/
import Mathlib.Algebra.BigOperators.Ring
import Mathlib.Analysis.Asymptotics.Asymptotics
import Mathlib.NumberTheory.ArithmeticFunction
import PrimeNumberTheoremAnd.Mathlib.NumberTheory.Sieve.AuxResults

noncomputable section

open scoped BigOperators ArithmeticFunction

open Finset Real Nat Aux

structure Sieve where mk ::
  support : Finset ‚Ñï
  prodPrimes : ‚Ñï
  prodPrimes_squarefree : Squarefree prodPrimes
  weights : ‚Ñï ‚Üí ‚Ñù
  weights_nonneg : ‚àÄ n : ‚Ñï, 0 ‚â§ weights n
  totalMass : ‚Ñù
  nu : ArithmeticFunction ‚Ñù
  nu_mult : nu.IsMultiplicative
  nu_pos_of_prime : ‚àÄ p : ‚Ñï, p.Prime ‚Üí p ‚à£ prodPrimes ‚Üí 0 < nu p
  nu_lt_one_of_prime : ‚àÄ p : ‚Ñï, p.Prime ‚Üí p ‚à£ prodPrimes ‚Üí nu p < 1

attribute [arith_mult] Sieve.nu_mult

namespace Sieve

variable (s : Sieve)
local notation3 "ŒΩ" => Sieve.nu s
local notation3 "P" => Sieve.prodPrimes s
local notation3 "a" => Sieve.weights s
local notation3 "X" => Sieve.totalMass s
local notation3 "A" => Sieve.support s

@[simp]
def multSum (d : ‚Ñï) : ‚Ñù :=
  ‚àë n in A, if d ‚à£ n then a n else 0

local notation3 "ùíú" => Sieve.multSum s

-- A_d = ŒΩ (d)/d X + R_d
@[simp]
def rem (d : ‚Ñï) : ‚Ñù :=
  ùíú d - ŒΩ d * X

local notation3 "R" => Sieve.rem s

def siftedSum : ‚Ñù :=
  ‚àë d in A, if Coprime P d then a d else 0

-- S = ‚àë_{l|P, l‚â§‚àöy} g(l)
-- Used in statement of the simple form of the selberg bound
def selbergTerms : ArithmeticFunction ‚Ñù :=
  s.nu.pmul (.prodPrimeFactors fun p =>  1 / (1 - ŒΩ p))

local notation3 "g" => Sieve.selbergTerms s

theorem selbergTerms_apply (d : ‚Ñï) :
    g d = ŒΩ d * ‚àè p in d.primeFactors, 1/(1 - ŒΩ p) := by
  unfold selbergTerms
  by_cases h : d=0
  ¬∑ rw [h]; simp
  rw [ArithmeticFunction.pmul_apply, ArithmeticFunction.prodPrimeFactors_apply h]

def mainSum (ŒºPlus : ‚Ñï ‚Üí ‚Ñù) : ‚Ñù :=
  ‚àë d in divisors P, ŒºPlus d * ŒΩ d

def errSum (ŒºPlus : ‚Ñï ‚Üí ‚Ñù) : ‚Ñù :=
  ‚àë d in divisors P, |ŒºPlus d| * |R d|


section UpperBoundSieve

def UpperMoebius (Œº_plus : ‚Ñï ‚Üí ‚Ñù) : Prop :=
  ‚àÄ n : ‚Ñï, (if n=1 then 1 else 0) ‚â§ ‚àë d in n.divisors, Œº_plus d

structure UpperBoundSieve where mk ::
  ŒºPlus : ‚Ñï ‚Üí ‚Ñù
  hŒºPlus : UpperMoebius ŒºPlus

instance ubToŒºPlus : CoeFun UpperBoundSieve fun _ => ‚Ñï ‚Üí ‚Ñù where coe ub := ub.ŒºPlus

def LowerMoebius (ŒºMinus : ‚Ñï ‚Üí ‚Ñù) : Prop :=
  ‚àÄ n : ‚Ñï, ‚àë d in n.divisors, ŒºMinus d ‚â§ (if n=1 then 1 else 0)

structure LowerBoundSieve where mk ::
  ŒºMinus : ‚Ñï ‚Üí ‚Ñù
  hŒºMinus : LowerMoebius ŒºMinus

instance lbToŒºMinus : CoeFun LowerBoundSieve fun _ => ‚Ñï ‚Üí ‚Ñù where coe lb := lb.ŒºMinus

end UpperBoundSieve

section SieveLemmas

theorem prodPrimes_ne_zero : P ‚â† 0 :=
  Squarefree.ne_zero s.prodPrimes_squarefree

theorem squarefree_of_dvd_prodPrimes {d : ‚Ñï} (hd : d ‚à£ P) : Squarefree d :=
  Squarefree.squarefree_of_dvd hd s.prodPrimes_squarefree

theorem squarefree_of_mem_divisors_prodPrimes {d : ‚Ñï} (hd : d ‚àà divisors P) : Squarefree d := by
  simp only [Nat.mem_divisors] at hd
  exact Squarefree.squarefree_of_dvd hd.left s.prodPrimes_squarefree

theorem nu_pos_of_dvd_prodPrimes {d : ‚Ñï} (hd : d ‚à£ P) : 0 < ŒΩ d := by
  calc
    0 < ‚àè p in d.primeFactors, ŒΩ p := by
      apply prod_pos
      intro p hpd
      have hp_prime : p.Prime := prime_of_mem_primeFactors hpd
      have hp_dvd : p ‚à£ P := (dvd_of_mem_primeFactors hpd).trans hd
      exact s.nu_pos_of_prime p hp_prime hp_dvd
    _ = ŒΩ d := s.nu_mult.prod_factors_of_mult ŒΩ (Squarefree.squarefree_of_dvd hd s.prodPrimes_squarefree)

theorem nu_ne_zero {d : ‚Ñï} (hd : d ‚à£ P) : ŒΩ d ‚â† 0 := by
  apply _root_.ne_of_gt
  exact nu_pos_of_dvd_prodPrimes s hd

theorem nu_ne_zero_of_mem_divisors_prodPrimes {d : ‚Ñï} (hd : d ‚àà divisors P) : ŒΩ d ‚â† 0 := by
  apply _root_.ne_of_gt
  rw [mem_divisors] at hd
  apply s.nu_pos_of_dvd_prodPrimes hd.left

theorem multSum_eq_main_err (d : ‚Ñï) : s.multSum d = ŒΩ d * X + R d := by
  dsimp [rem]
  ring

def delta (n : ‚Ñï) : ‚Ñù := if n=1 then 1 else 0

local notation "Œ¥" => delta

theorem siftedSum_as_delta : s.siftedSum = ‚àë d in s.support, a d * Œ¥ (Nat.gcd P d) :=
  by
  dsimp only [siftedSum]
  apply sum_congr rfl
  intro d _
  dsimp only [Nat.Coprime, delta] at *
  rw [mul_ite_zero]
  exact if_congr Iff.rfl (symm $ mul_one _) rfl

-- Unused ?
theorem nu_lt_self_of_dvd_prodPrimes (d : ‚Ñï) (hdP : d ‚à£ P) (hd_ne_one : d ‚â† 1) : ŒΩ d < 1 := by
  have hd_sq : Squarefree d := Squarefree.squarefree_of_dvd hdP s.prodPrimes_squarefree
  calc
    ŒΩ d = ‚àè p in d.primeFactors, ŒΩ p :=
      eq_comm.mp (s.nu_mult.prod_factors_of_mult ŒΩ hd_sq)
    _ < ‚àè p in d.primeFactors, 1 := by
      apply prod_lt_prod_of_nonempty
      ¬∑ intro p hp
        simp only [mem_primeFactors] at hp
        apply s.nu_pos_of_prime p (by aesop) (hp.2.1.trans hdP)
      ¬∑ intro p hpd; rw [mem_primeFactors_of_ne_zero hd_sq.ne_zero] at hpd
        apply s.nu_lt_one_of_prime p hpd.left (hpd.2.trans hdP)
      ¬∑ apply primeDivisors_nonempty _ <| (two_le_iff d).mpr ‚ü®hd_sq.ne_zero, hd_ne_one‚ü©
    _ = 1 := by
      simp

-- Facts about g
@[aesop safe]
theorem selbergTerms_pos (l : ‚Ñï) (hl : l ‚à£ P) : 0 < g l := by
  rw [selbergTerms_apply]
  apply mul_pos
  exact s.nu_pos_of_dvd_prodPrimes hl
  apply prod_pos
  intro p hp
  rw [one_div_pos]
  have hp_prime : p.Prime := prime_of_mem_primeFactors hp
  have hp_dvd : p ‚à£ P := (Nat.dvd_of_mem_primeFactors hp).trans hl
  linarith only [s.nu_lt_one_of_prime p hp_prime hp_dvd]

theorem selbergTerms_mult : ArithmeticFunction.IsMultiplicative g := by
  unfold selbergTerms
  arith_mult

theorem one_div_selbergTerms_eq_conv_moebius_nu (l : ‚Ñï) (hl : Squarefree l)
    (hnu_nonzero : ŒΩ l ‚â† 0) : 1 / g l = ‚àë d in l.divisors, (Œº <| l / d) * (ŒΩ d)‚Åª¬π :=
  by
  rw [selbergTerms_apply]
  simp only [one_div, mul_inv, inv_div, inv_inv, Finset.prod_congr, Finset.prod_inv_distrib]
  rw [(s.nu_mult).prodPrimeFactors_one_sub_of_squarefree _ hl]
  rw [mul_sum]
  apply symm
  rw [‚Üê Nat.sum_divisorsAntidiagonal' fun d e : ‚Ñï => ‚Üë(Œº d) * (ŒΩ e)‚Åª¬π]
  rw [Nat.sum_divisorsAntidiagonal fun d e : ‚Ñï => ‚Üë(Œº d) * (ŒΩ e)‚Åª¬π]
  apply sum_congr rfl; intro d hd
  have hd_dvd : d ‚à£ l := dvd_of_mem_divisors hd
  rw [‚Üêdiv_mult_of_dvd_squarefree ŒΩ s.nu_mult l d (dvd_of_mem_divisors hd) hl, inv_div]
  ring
  revert hnu_nonzero; contrapose!
  exact multiplicative_zero_of_zero_dvd ŒΩ s.nu_mult hl hd_dvd

theorem nu_eq_conv_one_div_selbergTerms (d : ‚Ñï) (hdP : d ‚à£ P) :
    (ŒΩ d)‚Åª¬π = ‚àë l in divisors P, if l ‚à£ d then 1 / g l else 0 := by
  apply symm
  rw [‚Üêsum_filter, Nat.divisors_filter_dvd_of_dvd s.prodPrimes_ne_zero hdP]
  have hd_pos : 0 < d := Nat.pos_of_ne_zero $ ne_zero_of_dvd_ne_zero s.prodPrimes_ne_zero hdP
  revert hdP; revert d
  apply (ArithmeticFunction.sum_eq_iff_sum_mul_moebius_eq_on _ (fun _ _ => Nat.dvd_trans)).mpr
  intro l _ hlP
  rw [sum_divisorsAntidiagonal' (f:=fun x y => (Œº <| x) * (ŒΩ y)‚Åª¬π) (n:=l)]
  apply symm
  exact s.one_div_selbergTerms_eq_conv_moebius_nu l
    (Squarefree.squarefree_of_dvd hlP s.prodPrimes_squarefree)
    (_root_.ne_of_gt $ s.nu_pos_of_dvd_prodPrimes hlP)

theorem conv_selbergTerms_eq_selbergTerms_mul_nu {d : ‚Ñï} (hd : d ‚à£ P) :
    (‚àë l in divisors P, if l ‚à£ d then g l else 0) = g d * (ŒΩ d)‚Åª¬π := by
  calc
    (‚àë l in divisors P, if l ‚à£ d then g l else 0) =
        ‚àë l in divisors P, if l ‚à£ d then g (d / l) else 0 := by
      rw [‚Üê sum_over_dvd_ite s.prodPrimes_ne_zero hd,
        ‚Üê Nat.sum_divisorsAntidiagonal fun x _ => g x, Nat.sum_divisorsAntidiagonal' fun x _ => g x,
        sum_over_dvd_ite s.prodPrimes_ne_zero hd]
    _ = g d * ‚àë l in divisors P, if l ‚à£ d then 1 / g l else 0 := by
      rw [mul_sum]; apply sum_congr rfl; intro l hl
      rw [mul_ite_zero]; apply if_ctx_congr Iff.rfl _ (fun _ => rfl); intro h
      rw [‚Üê div_mult_of_dvd_squarefree g s.selbergTerms_mult d l]; ring
      exact h; apply Squarefree.squarefree_of_dvd hd s.prodPrimes_squarefree
      apply _root_.ne_of_gt; rw [mem_divisors] at hl ; apply selbergTerms_pos; exact hl.left
    _ = g d * (ŒΩ d)‚Åª¬π := by rw [‚Üê s.nu_eq_conv_one_div_selbergTerms d hd]

theorem upper_bound_of_UpperBoundSieve (ŒºPlus : UpperBoundSieve) :
    s.siftedSum ‚â§ ‚àë d in divisors P, ŒºPlus d * s.multSum d := by
  have hŒº : ‚àÄ n, Œ¥ n ‚â§ ‚àë d in n.divisors, ŒºPlus d := ŒºPlus.hŒºPlus
  rw [siftedSum_as_delta]
  trans (‚àë n in s.support, a n * ‚àë d in (Nat.gcd P n).divisors, ŒºPlus d)
  ¬∑ apply Finset.sum_le_sum; intro n _
    exact mul_le_mul_of_nonneg_left (hŒº (Nat.gcd P n)) (s.weights_nonneg n)
  apply le_of_eq
  trans (‚àë n in s.support, ‚àë d in divisors P, if d ‚à£ n then a n * ŒºPlus d else 0)
  ¬∑ apply sum_congr rfl; intro n _;
    rw [mul_sum, sum_over_dvd_ite s.prodPrimes_ne_zero (Nat.gcd_dvd_left _ _), sum_congr rfl]; intro d hd
    apply if_congr _ rfl rfl
    rw [Nat.dvd_gcd_iff, and_iff_right (dvd_of_mem_divisors hd)]
  rw [sum_comm, sum_congr rfl]; intro d _
  dsimp only [multSum]
  rw [mul_sum, sum_congr rfl]; intro n _
  rw [‚Üêite_zero_mul, mul_comm]

theorem siftedSum_le_mainSum_errSum_of_UpperBoundSieve (ŒºPlus : UpperBoundSieve) :
    s.siftedSum ‚â§ X * s.mainSum ŒºPlus + s.errSum ŒºPlus := by
  dsimp only [mainSum, errSum]
  trans (‚àë d in divisors P, ŒºPlus d * s.multSum d)
  ¬∑ apply upper_bound_of_UpperBoundSieve
  trans ( X * ‚àë d in divisors P, ŒºPlus d * ŒΩ d + ‚àë d in divisors P, ŒºPlus d * R d )
  ¬∑ apply le_of_eq
    rw [mul_sum, ‚Üêsum_add_distrib]
    apply sum_congr rfl; intro d _
    dsimp only [rem]; ring
  apply _root_.add_le_add (le_rfl)
  apply sum_le_sum; intro d _
  rw [‚Üêabs_mul]
  exact le_abs_self (UpperBoundSieve.ŒºPlus ŒºPlus d * rem s d)

end SieveLemmas

-- Results about Lambda Squared Sieves
section LambdaSquared

def lambdaSquared (weights : ‚Ñï ‚Üí ‚Ñù) : ‚Ñï ‚Üí ‚Ñù := fun d =>
  ‚àë d1 in d.divisors, ‚àë d2 in d.divisors, if d = Nat.lcm d1 d2 then weights d1 * weights d2 else 0

private theorem lambdaSquared_eq_zero_of_support_wlog {w : ‚Ñï ‚Üí ‚Ñù} {y : ‚Ñù} (hw : ‚àÄ (d : ‚Ñï), ¬¨d ^ 2 ‚â§ y ‚Üí w d = 0)
    {d : ‚Ñï} (hd : ¬¨‚Üëd ‚â§ y) (d1 : ‚Ñï) (d2 : ‚Ñï) (h : d = Nat.lcm d1 d2) (hle : d1 ‚â§ d2) :
    w d1 * w d2 = 0 := by
  rw [hw d2]; ring
  by_contra hyp; apply hd
  apply le_trans _ hyp
  norm_cast
  calc _ ‚â§ (d1.lcm d2) := by rw [h]
      _ ‚â§ (d1*d2) := Nat.div_le_self _ _
      _ ‚â§ _       := ?_
  ¬∑ rw [sq]; gcongr

theorem lambdaSquared_eq_zero_of_support (w : ‚Ñï ‚Üí ‚Ñù) (y : ‚Ñù)
    (hw : ‚àÄ d : ‚Ñï, ¬¨d ^ 2 ‚â§ y ‚Üí w d = 0) (d : ‚Ñï) (hd : ¬¨d ‚â§ y) :
    lambdaSquared w d = 0 := by
  dsimp only [lambdaSquared]
  by_cases hy : 0 ‚â§ y
  swap
  ¬∑ push_neg at hd hy
    have : ‚àÄ d' : ‚Ñï, w d' = 0 := by
      intro d'; apply hw
      have : (0:‚Ñù) ‚â§ (d') ^ 2 := by norm_num
      linarith
    apply sum_eq_zero; intro d1 _
    apply sum_eq_zero; intro d2 _
    rw [this d1, this d2]
    simp only [ite_self, eq_self_iff_true, MulZeroClass.mul_zero]
  apply sum_eq_zero; intro d1 _; apply sum_eq_zero; intro d2 _
  split_ifs with h
  swap; rfl
  rcases Nat.le_or_le d1 d2 with hle | hle
  ¬∑ apply lambdaSquared_eq_zero_of_support_wlog hw hd d1 d2 h hle
  ¬∑ rw[mul_comm]
    apply lambdaSquared_eq_zero_of_support_wlog hw hd d2 d1 (Nat.lcm_comm d1 d2 ‚ñ∏ h) hle

theorem upperMoebius_of_lambda_sq (weights : ‚Ñï ‚Üí ‚Ñù) (hw : weights 1 = 1) :
    UpperMoebius <| lambdaSquared weights := by
  dsimp [UpperMoebius, lambdaSquared]
  intro n
  have h_sq :
    (‚àë d in n.divisors, ‚àë d1 in d.divisors, ‚àë d2 in d.divisors,
      if d = Nat.lcm d1 d2 then weights d1 * weights d2 else 0) =
      (‚àë d in n.divisors, weights d) ^ 2 := by
    rw [sq, mul_sum, conv_lambda_sq_larger_sum _ n, sum_comm]
    apply sum_congr rfl; intro d1 hd1
    rw [sum_mul, sum_comm]
    apply sum_congr rfl; intro d2 hd2
    rw [‚ÜêAux.sum_intro]
    ring
    rw [mem_divisors, Nat.lcm_dvd_iff]
    exact ‚ü®‚ü®dvd_of_mem_divisors hd1, dvd_of_mem_divisors hd2‚ü©, (mem_divisors.mp hd1).2‚ü©
  rw [h_sq]
  split_ifs with hn
  ¬∑ rw [hn]; simp [hw]
  ¬∑ apply sq_nonneg

-- set_option quotPrecheck false
-- variable (s : Sieve)

-- local notation3 "ŒΩ" => Sieve.nu s
-- local notation3 "P" => Sieve.prodPrimes s
-- local notation3 "a" => Sieve.weights s
-- local notation3 "X" => Sieve.totalMass s
-- local notation3 "R" => Sieve.rem s
-- local notation3 "g" => Sieve.selbergTerms s

theorem lambdaSquared_mainSum_eq_quad_form (w : ‚Ñï ‚Üí ‚Ñù) :
    s.mainSum (lambdaSquared w) =
      ‚àë d1 in divisors P, ‚àë d2 in divisors P,
        ŒΩ d1 * w d1 * ŒΩ d2 * w d2 * (ŒΩ (d1.gcd d2))‚Åª¬π := by
  dsimp only [mainSum, lambdaSquared]
  trans (‚àë d in divisors P, ‚àë d1 in divisors d, ‚àë d2 in divisors d,
          if d = d1.lcm d2 then w d1 * w d2 * ŒΩ d else 0)
  ¬∑ rw [sum_congr rfl]; intro d _
    rw [sum_mul, sum_congr rfl]; intro d1 _
    rw [sum_mul, sum_congr rfl]; intro d2 _
    rw [ite_zero_mul]

  trans (‚àë d in divisors P, ‚àë d1 in divisors P, ‚àë d2 in divisors P,
          if d = d1.lcm d2 then w d1 * w d2 * ŒΩ d else 0)
  ¬∑ apply conv_lambda_sq_larger_sum
  rw [sum_comm, sum_congr rfl]; intro d1 hd1
  rw [sum_comm, sum_congr rfl]; intro d2 hd2
  have h : d1.lcm d2 ‚à£ P := Nat.lcm_dvd_iff.mpr ‚ü®dvd_of_mem_divisors hd1, dvd_of_mem_divisors hd2‚ü©
  rw [‚Üêsum_intro (divisors P) (d1.lcm d2) (mem_divisors.mpr ‚ü®h, s.prodPrimes_ne_zero‚ü© )]
  rw [s.nu_mult.mult_lcm_eq_of_ne_zero]
  ring
  refine _root_.ne_of_gt (s.nu_pos_of_dvd_prodPrimes ?_)
  trans d1
  ¬∑ exact Nat.gcd_dvd_left d1 d2
  ¬∑ exact dvd_of_mem_divisors hd1

theorem lambdaSquared_mainSum_eq_diag_quad_form  (w : ‚Ñï ‚Üí ‚Ñù) :
    s.mainSum (lambdaSquared w) =
      ‚àë l in divisors P,
        1 / g l * (‚àë d in divisors P, if l ‚à£ d then ŒΩ d * w d else 0) ^ 2 :=
  by
  rw [s.lambdaSquared_mainSum_eq_quad_form w]
  trans (‚àë d1 in divisors P, ‚àë d2 in divisors P, (‚àë l in divisors P,
          if l ‚à£ d1.gcd d2 then 1 / g l * (ŒΩ d1 * w d1) * (ŒΩ d2 * w d2) else 0))
  ¬∑ apply sum_congr rfl; intro d1 hd1; apply sum_congr rfl; intro d2 _
    have hgcd_dvd: d1.gcd d2 ‚à£ P := Trans.trans (Nat.gcd_dvd_left d1 d2) (dvd_of_mem_divisors hd1)
    rw [s.nu_eq_conv_one_div_selbergTerms _ hgcd_dvd, mul_sum]
    apply sum_congr rfl; intro l _
    rw [mul_ite_zero]; apply if_congr Iff.rfl _ rfl
    ring
  trans (‚àë l in divisors P, ‚àë d1 in divisors P, ‚àë d2 in divisors P,
        if l ‚à£ Nat.gcd d1 d2 then 1 / selbergTerms s l * (ŒΩ d1 * w d1) * (ŒΩ d2 * w d2) else 0)
  ¬∑ apply symm; rw [sum_comm, sum_congr rfl]; intro d1 _; rw[sum_comm];
  apply sum_congr rfl; intro l _
  rw [sq, sum_mul, mul_sum, sum_congr rfl]; intro d1 _
  rw [mul_sum, mul_sum, sum_congr rfl]; intro d2 _
  rw [ite_zero_mul_ite_zero, mul_ite_zero]
  apply if_congr (Nat.dvd_gcd_iff) _ rfl;
  ring

end LambdaSquared

end Sieve
