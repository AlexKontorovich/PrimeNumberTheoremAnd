import Lean
import Lean.Util.FoldConsts
import Lean.Data.Json

open Lean


def dottedToName (s : String) : Name :=
  let parts := s.splitOn "."
  parts.foldl (fun n p => if p.isEmpty then n else Name.str n p) Name.anonymous

/-- Convert `PrimeNumberTheoremAnd/Lcm.lean` or `PrimeNumberTheoremAnd.Lcm`
    into module name `PrimeNumberTheoremAnd.Lcm`. -/
def argToModuleName (s : String) : Name :=
  let s :=
    if s.endsWith ".lean" then s.dropRight 5 else s
  let s := (s.replace "/" ".").replace "\\" "."
  dottedToName s

/-- Substring test (Lean 4.25+ style): `String.Slice.contains`. -/
def containsSubstr (s sub : String) : Bool :=
  s.toSlice.contains sub

/-- Filter out some common autogenerated names. Tweak as you like. -/
def isAutoGenerated (n : Name) : Bool :=
  let s := toString n
  containsSubstr s "._uniq" ||
  containsSubstr s "._match" ||
  containsSubstr s "_private" ||
  containsSubstr s "match_"

/-- Load an environment with `mod` imported. -/
def loadEnv (mod : Name) : IO Environment := do
  importModules #[{ module := mod }] (opts := Options.empty)

/-- True iff `decl` was declared in module `mod`. -/
def definedInModule (env : Environment) (mod : Name) (decl : Name) : Bool :=
  match env.getModuleIdxFor? decl, env.getModuleIdx? mod with
  | some iDecl, some iMod => iDecl == iMod
  | _, _ => false

/-- Get constants used by a declaration's *type* and (if present) *value*. -/
def usedConstsOf (ci : ConstantInfo) : NameSet :=
  -- ConstantInfo.getUsedConstantsAsSet comes from Lean.Util.FoldConsts
  ci.getUsedConstantsAsSet

def main (args : List String) : IO Unit := do
  let targetStr ←
    match args with
    | s :: _ => pure s
    | [] => throw <| IO.userError "Usage: Deps <TargetModuleOrFile.lean>"

  let targetMod := argToModuleName targetStr
  let env ← loadEnv targetMod

  -- all constants declared in *this module*
  let decls : Array Name :=
    env.constants.fold (init := #[]) (fun acc n _ci =>
      if definedInModule env targetMod n && !isAutoGenerated n then
        acc.push n
      else
        acc
    )

  let declSet : NameSet :=
    decls.foldl (fun s n => s.insert n) (∅)

  for n in decls do
    match env.find? n with
    | none =>
        -- should not happen for env.constants keys, but harmless
        pure ()
    | some ci =>
        let depsAll := usedConstsOf ci
        let depsLocal :=
          (depsAll.toList.filter fun d => d != n && declSet.contains d)

        if depsLocal.isEmpty then
          IO.println s!"{n} -> None"
        else
          IO.println s!"{n} -> {depsLocal}"
