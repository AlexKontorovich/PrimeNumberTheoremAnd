import PrimeNumberTheoremAnd.ZetaBounds
import Mathlib.Algebra.Group.Support

set_option lang.lemmaCmd true

open Set Function Filter Complex Real

local notation (name := mellintransform2) "ùìú" => MellinTransform


/-%%
The approach here is completely standard. We follow the use of
$\mathcal{M}(\widetilde{1_{\epsilon}})$ as in Kontorovich 2015.
%%-/

/-%%
It has already been established that zeta doesn't vanish on the 1 line, and has a pole at $s=1$
of order 1.
We also have the following.
\begin{theorem}[LogDerivativeDirichlet]\label{LogDerivativeDirichlet}\lean{LogDerivativeDirichlet}\leanok
We have that, for $\Re(s)>1$,
$$
-\frac{\zeta'(s)}{\zeta(s)} = \sum_{n=1}^\infty \frac{\Lambda(n)}{n^s}.
$$
\end{theorem}
%%-/
open scoped ArithmeticFunction in
theorem LogDerivativeDirichlet (s : ‚ÑÇ) (hs : 1 < s.re) :
    - deriv riemannZeta s / riemannZeta s = ‚àë' n, Œõ n / (n : ‚ÑÇ) ^ s := by
  rw [‚Üê ArithmeticFunction.LSeries_vonMangoldt_eq_deriv_riemannZeta_div hs]
  dsimp [LSeries, LSeries.term]
  nth_rewrite 2 [tsum_eq_add_tsum_ite (b := 0) ?_]
  ¬∑ simp
  ¬∑ have := ArithmeticFunction.LSeriesSummable_vonMangoldt hs
    dsimp [LSeriesSummable] at this
    convert this; rename ‚Ñï => n
    by_cases h : n = 0 <;> simp [LSeries.term, h]
/-%%
\begin{proof}\leanok
Already in Mathlib.
\end{proof}


The main object of study is the following inverse Mellin-type transform, which will turn out to
be a smoothed Chebyshev function.

\begin{definition}[SmoothedChebyshev]\label{SmoothedChebyshev}\lean{SmoothedChebyshev}\leanok
Fix $\epsilon>0$, and a bumpfunction supported in $[1/2,2]$. Then we define the smoothed
Chebyshev function $\psi_{\epsilon}$ from $\mathbb{R}_{>0}$ to $\mathbb{C}$ by
$$\psi_{\epsilon}(X) = \frac{1}{2\pi i}\int_{(\sigma)}\frac{-\zeta'(s)}{\zeta(s)}
\mathcal{M}(\widetilde{1_{\epsilon}})(s)
X^{s}ds,$$
where we'll take $\sigma = 1 + 1 / \log X$.
\end{definition}
%%-/
noncomputable abbrev SmoothedChebyshevIntegrand (SmoothingF : ‚Ñù ‚Üí ‚Ñù) (Œµ : ‚Ñù) (X : ‚Ñù) : ‚ÑÇ ‚Üí ‚ÑÇ :=
  fun s ‚Ü¶ (- deriv riemannZeta s) / riemannZeta s *
    ùìú ((Smooth1 SmoothingF Œµ) ¬∑) s * (X : ‚ÑÇ) ^ s

noncomputable def SmoothedChebyshev (SmoothingF : ‚Ñù ‚Üí ‚Ñù) (Œµ : ‚Ñù) (X : ‚Ñù) : ‚ÑÇ :=
  VerticalIntegral' (SmoothedChebyshevIntegrand SmoothingF Œµ X) ((1 : ‚Ñù) + (Real.log X)‚Åª¬π)


open MeasureTheory

/-%%
\begin{lemma}[SmoothedChebyshevDirichlet_aux_integrable]\label{SmoothedChebyshevDirichlet_aux_integrable}\lean{SmoothedChebyshevDirichlet_aux_integrable}\leanok
Fix a nonnegative, continuously differentiable function $F$ on $\mathbb{R}$ with support in $[1/2,2]$, and total mass one, $\int_{(0,\infty)} F(x)/x dx = 1$. Then for any $\epsilon>0$, and $\sigma\in (1, 2]$, the function
$$
x \mapsto\mathcal{M}(\widetilde{1_{\epsilon}})(\sigma + ix)
$$
is integrable on $\mathbb{R}$.
\end{lemma}
%%-/
lemma SmoothedChebyshevDirichlet_aux_integrable {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (diffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    (SmoothingFpos : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
    (suppSmoothingF : support SmoothingF ‚äÜ Icc (1 / 2) 2)
    (mass_one : ‚à´ (x : ‚Ñù) in Ioi 0, SmoothingF x / x = 1)
    {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) (Œµ_lt_one : Œµ < 1) {œÉ : ‚Ñù} (œÉ_gt : 1 < œÉ) (œÉ_le : œÉ ‚â§ 2) :
    MeasureTheory.Integrable
      (fun (y : ‚Ñù) ‚Ü¶ ùìú (fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (œÉ + y * I)) := by
  obtain ‚ü®c, cpos, hc‚ü© := MellinOfSmooth1b diffSmoothingF suppSmoothingF
  apply Integrable.mono' (g := (fun t ‚Ü¶ c / Œµ * 1 / (1 + t ^ 2)))
  ¬∑ apply Integrable.const_mul integrable_inv_one_add_sq
  ¬∑ apply Continuous.aestronglyMeasurable
    apply continuous_iff_continuousAt.mpr
    intro x
    have := Smooth1MellinDifferentiable diffSmoothingF suppSmoothingF ‚ü®Œµpos, Œµ_lt_one‚ü©
      SmoothingFpos mass_one (s := œÉ + x * I) (by simp only [add_re, ofReal_re, mul_re, I_re,
        mul_zero, ofReal_im, I_im, mul_one, sub_self, add_zero]; linarith) |>.continuousAt
    fun_prop
  ¬∑ filter_upwards [] with t
    calc
      _‚â§ c / Œµ * 1 / (œÉ^2 + t^2) := by
        convert hc (œÉ / 2) (by linarith) (œÉ + t * I) (by simp only [add_re, ofReal_re, mul_re,
          I_re, mul_zero, ofReal_im, I_im, mul_one, sub_self, add_zero, half_le_self_iff]; linarith)
          (by simp only [add_re, ofReal_re, mul_re, I_re, mul_zero, ofReal_im, I_im, mul_one,
            sub_self, add_zero]; linarith) Œµ Œµpos  Œµ_lt_one using 1
        simp only [mul_one, Complex.sq_norm, normSq_apply, add_re, ofReal_re, mul_re, I_re,
          mul_zero, ofReal_im, I_im, sub_self, add_zero, add_im, mul_im, zero_add, mul_inv_rev]
        ring_nf
      _ ‚â§ _ := by
        gcongr; nlinarith

/-%%
\begin{proof}\leanok
\uses{MellinOfSmooth1b}
By Lemma \ref{MellinOfSmooth1b} the integrand is $O(1/t^2)$ as $t\rightarrow \infty$ and hence the function is integrable.
\end{proof}
%%-/

/-%%
\begin{lemma}[SmoothedChebyshevDirichlet_aux_tsum_integral]\label{SmoothedChebyshevDirichlet_aux_tsum_integral}
\lean{SmoothedChebyshevDirichlet_aux_tsum_integral}\leanok
Fix a nonnegative, continuously differentiable function $F$ on $\mathbb{R}$ with support in
$[1/2,2]$, and total mass one, $\int_{(0,\infty)} F(x)/x dx = 1$. Then for any $\epsilon>0$ and $\sigma\in(1,2]$, the
function
$x \mapsto \sum_{n=1}^\infty \frac{\Lambda(n)}{n^{\sigma+it}}
\mathcal{M}(\widetilde{1_{\epsilon}})(\sigma+it) x^{\sigma+it}$ is equal to
$\sum_{n=1}^\infty \int_{(0,\infty)} \frac{\Lambda(n)}{n^{\sigma+it}}
\mathcal{M}(\widetilde{1_{\epsilon}})(\sigma+it) x^{\sigma+it}$.
\end{lemma}
%%-/

-- TODO: add to mathlib
attribute [fun_prop] Continuous.const_cpow

lemma SmoothedChebyshevDirichlet_aux_tsum_integral {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (diffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    (SmoothingFpos : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
    (suppSmoothingF : support SmoothingF ‚äÜ Icc (1 / 2) 2)
    (mass_one : ‚à´ (x : ‚Ñù) in Ioi 0, SmoothingF x / x = 1) (X : ‚Ñù)
    (X_pos : 0 < X) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ)
    (Œµ_lt_one : Œµ < 1) {œÉ : ‚Ñù} (œÉ_gt : 1 < œÉ) (œÉ_le : œÉ ‚â§ 2) :
    ‚à´ (t : ‚Ñù),
      ‚àë' (n : ‚Ñï), (ArithmeticFunction.vonMangoldt n) / (n : ‚ÑÇ) ^ (œÉ + t * I) *
        ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + t * I) * (X : ‚ÑÇ) ^ (œÉ + t * I) =
    ‚àë' (n : ‚Ñï),
      ‚à´ (t : ‚Ñù), (ArithmeticFunction.vonMangoldt n) / (n : ‚ÑÇ) ^ (œÉ + ‚Üët * I) *
        ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + ‚Üët * I) * (X : ‚ÑÇ) ^ (œÉ + t * I) := by

  have cont_mellin_smooth : Continuous fun (a : ‚Ñù) ‚Ü¶
      ùìú (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + ‚Üëa * I) := by
    rw [continuous_iff_continuousOn_univ]
    refine ContinuousOn.comp' ?_ ?_ ?_ (t := {z : ‚ÑÇ | 0 < z.re })
    . refine continuousOn_of_forall_continuousAt ?_
      intro z hz
      exact (Smooth1MellinDifferentiable diffSmoothingF suppSmoothingF ‚ü®Œµpos, Œµ_lt_one‚ü© SmoothingFpos mass_one hz).continuousAt
    . fun_prop
    . simp only [mapsTo_univ_iff, mem_setOf_eq, add_re, ofReal_re, mul_re, I_re, mul_zero,
        ofReal_im, I_im, mul_one, sub_self, add_zero, forall_const]; linarith

  have abs_two : ‚àÄ a : ‚Ñù, ‚àÄ i : ‚Ñï, ‚Äñ(i : ‚ÑÇ) ^ ((œÉ : ‚ÑÇ) + ‚Üëa * I)‚Äñ‚Çä = i ^ œÉ := by
    intro a i
    simp_rw [‚Üê norm_toNNReal]
    -- norm_cast
    rw [norm_natCast_cpow_of_re_ne_zero _ (by simp only [add_re, ofReal_re, mul_re, I_re, mul_zero,
      ofReal_im, I_im, mul_one, sub_self, add_zero, ne_eq]; linarith)]
    simp only [add_re, re_ofNat, mul_re, ofReal_re, I_re, mul_zero, ofReal_im, I_im, mul_one,
      sub_self, add_zero, rpow_two, Real.toNNReal_of_nonneg <| rpow_nonneg (y:= œÉ) (x:= i) (by linarith)]
    norm_cast

  rw [MeasureTheory.integral_tsum]
  have x_neq_zero : X ‚â† 0 := by linarith
  . intro i
    by_cases i_eq_zero : i = 0
    . simpa [i_eq_zero] using aestronglyMeasurable_const
    . apply Continuous.aestronglyMeasurable
      fun_prop (disch := simp[i_eq_zero, x_neq_zero])
  . rw [‚Üê lt_top_iff_ne_top]
    simp_rw [enorm_mul, enorm_eq_nnnorm, nnnorm_div, ‚Üê norm_toNNReal, Complex.norm_cpow_eq_rpow_re_of_pos X_pos, norm_toNNReal, abs_two]
    simp only [nnnorm_real, add_re, re_ofNat, mul_re, ofReal_re, I_re, mul_zero, ofReal_im, I_im,
      mul_one, sub_self, add_zero, rpow_two]
    simp_rw [MeasureTheory.lintegral_mul_const' (r := ‚Üë(X ^ œÉ).toNNReal) (hr := by simp), ENNReal.tsum_mul_right]
    apply WithTop.mul_lt_top ?_ ENNReal.coe_lt_top

    conv =>
      arg 1
      arg 1
      intro i
      rw [MeasureTheory.lintegral_const_mul' (hr := by simp)]

    rw [ENNReal.tsum_mul_right]
    apply WithTop.mul_lt_top
    . rw [WithTop.lt_top_iff_ne_top, ENNReal.tsum_coe_ne_top_iff_summable_coe]
      push_cast
      convert (ArithmeticFunction.LSeriesSummable_vonMangoldt (s := œÉ)
        (by simp only [ofReal_re]; linarith)).norm
      rw [LSeries.term_def]
      split_ifs with h <;> simp[h]
    . simp_rw [‚Üê enorm_eq_nnnorm]
      rw [‚Üê MeasureTheory.hasFiniteIntegral_iff_enorm]
      exact SmoothedChebyshevDirichlet_aux_integrable diffSmoothingF SmoothingFpos suppSmoothingF
            mass_one Œµpos Œµ_lt_one œÉ_gt œÉ_le |>.hasFiniteIntegral

/-%%
\begin{proof}\leanok
\uses{Smooth1Properties_above, SmoothedChebyshevDirichlet_aux_integrable}
Interchange of summation and integration.
\end{proof}
%%-/

/-%%
Inserting the Dirichlet series expansion of the log derivative of zeta, we get the following.
\begin{theorem}[SmoothedChebyshevDirichlet]\label{SmoothedChebyshevDirichlet}
\lean{SmoothedChebyshevDirichlet}\leanok
We have that
$$\psi_{\epsilon}(X) = \sum_{n=1}^\infty \Lambda(n)\widetilde{1_{\epsilon}}(n/X).$$
\end{theorem}
%%-/
theorem SmoothedChebyshevDirichlet {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (diffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    (SmoothingFpos : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2)
    (mass_one: ‚à´ x in Ioi (0 : ‚Ñù), SmoothingF x / x = 1)
    {X : ‚Ñù} (X_gt : 3 < X) {Œµ : ‚Ñù} (Œµpos: 0 < Œµ) (Œµ_lt_one : Œµ < 1) :
    SmoothedChebyshev SmoothingF Œµ X =
      ‚àë' n, ArithmeticFunction.vonMangoldt n * Smooth1 SmoothingF Œµ (n / X) := by
  dsimp [SmoothedChebyshev, SmoothedChebyshevIntegrand, VerticalIntegral', VerticalIntegral]
  rw [MellinTransform_eq]
  set Œõ := ArithmeticFunction.vonMangoldt
  set œÉ : ‚Ñù := 1 + (Real.log X)‚Åª¬π
  have log_gt : 1 < Real.log X := by
    rw [Real.lt_log_iff_exp_lt (by linarith : 0 < X)]
    linarith [Real.exp_one_lt_d9]
  have œÉ_gt : 1 < œÉ := by
    simp only [œÉ]
    have : 0 < (Real.log X)‚Åª¬π := by
      simp only [inv_pos]
      linarith
    linarith
  have œÉ_le : œÉ ‚â§ 2 := by
    simp only [œÉ]
    have : (Real.log X)‚Åª¬π < 1 := inv_lt_one_of_one_lt‚ÇÄ log_gt
    linarith
  calc
    _ = 1 / (2 * œÄ * I) * (I * ‚à´ (t : ‚Ñù), ‚àë' n, Œõ n / (n : ‚ÑÇ) ^ (œÉ + ‚Üët * I) *
      mellin (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + ‚Üët * I) * X ^ (œÉ + ‚Üët * I)) := ?_
    _ = 1 / (2 * œÄ * I) * (I * ‚àë' n, ‚à´ (t : ‚Ñù), Œõ n / (n : ‚ÑÇ) ^ (œÉ + ‚Üët * I) *
      mellin (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + ‚Üët * I) * X ^ (œÉ + ‚Üët * I)) := ?_
    _ = 1 / (2 * œÄ * I) * (I * ‚àë' n, Œõ n * ‚à´ (t : ‚Ñù),
      mellin (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + ‚Üët * I) * (X / (n : ‚ÑÇ)) ^ (œÉ + ‚Üët * I)) := ?_
    _ = 1 / (2 * œÄ) * (‚àë' n, Œõ n * ‚à´ (t : ‚Ñù),
      mellin (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + ‚Üët * I) * (X / (n : ‚ÑÇ)) ^ (œÉ + ‚Üët * I)) := ?_
    _ = ‚àë' n, Œõ n * (1 / (2 * œÄ) * ‚à´ (t : ‚Ñù),
      mellin (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + ‚Üët * I) * (X / (n : ‚ÑÇ)) ^ (œÉ + ‚Üët * I)) := ?_
    _ = ‚àë' n, Œõ n * (1 / (2 * œÄ) * ‚à´ (t : ‚Ñù),
      mellin (fun x ‚Ü¶ ‚Üë(Smooth1 SmoothingF Œµ x)) (œÉ + ‚Üët * I) * ((n : ‚ÑÇ) / X) ^ (-(œÉ + ‚Üët * I))) := ?_
    _ = _ := ?_
  ¬∑ congr; ext t
    rw [LogDerivativeDirichlet]
    ¬∑ rw [‚Üê tsum_mul_right, ‚Üê tsum_mul_right]
    ¬∑ simp [œÉ_gt]
  ¬∑ congr
    rw [‚Üê MellinTransform_eq]
    exact SmoothedChebyshevDirichlet_aux_tsum_integral diffSmoothingF SmoothingFpos
      suppSmoothingF mass_one X (by linarith) Œµpos Œµ_lt_one œÉ_gt œÉ_le
  ¬∑ field_simp; congr; ext n; rw [‚Üê MeasureTheory.integral_mul_left ]; congr; ext t
    by_cases n_ne_zero : n = 0; simp [n_ne_zero]
    rw [mul_div_assoc, mul_assoc]
    congr
    rw [(div_eq_iff ?_).mpr]
    have := @mul_cpow_ofReal_nonneg (a := X / (n : ‚Ñù)) (b := (n : ‚Ñù)) (r := œÉ + t * I) ?_ ?_
    push_cast at this ‚ä¢
    rw [‚Üê this, div_mul_cancel‚ÇÄ]
    ¬∑ simp only [ne_eq, Nat.cast_eq_zero, n_ne_zero, not_false_eq_true]
    ¬∑ apply div_nonneg (by linarith : 0 ‚â§ X); simp
    ¬∑ simp
    ¬∑ simp only [ne_eq, cpow_eq_zero_iff, Nat.cast_eq_zero, not_and, not_not]
      intro hn; exfalso; exact n_ne_zero hn
  ¬∑ conv => rw [‚Üê mul_assoc, div_mul]; lhs; lhs; rhs; simp
  ¬∑ simp_rw [‚Üê tsum_mul_left, ‚Üê mul_assoc, mul_comm]
  ¬∑ have ht (t : ‚Ñù) : -(œÉ + t * I) = (-1) * (œÉ + t * I) := by simp
    have hn (n : ‚ÑÇ) : (n / X) ^ (-1 : ‚ÑÇ) = X / n := by simp [cpow_neg_one]
    have (n : ‚Ñï) : (log ((n : ‚ÑÇ) / (X : ‚ÑÇ)) * -1).im = 0 := by
      simp [Complex.log_im, arg_eq_zero_iff, div_nonneg (Nat.cast_nonneg _) (by linarith : 0 ‚â§ X)]
    have h (n : ‚Ñï) (t : ‚Ñù) : ((n : ‚ÑÇ) / X) ^ ((-1 : ‚ÑÇ) * (œÉ + t * I)) =
        ((n / X) ^ (-1 : ‚ÑÇ)) ^ (œÉ + ‚Üët * I) := by
      rw [cpow_mul] <;> {rw [this n]; simp [Real.pi_pos, Real.pi_nonneg]}
    conv => rhs; rhs; intro n; rhs; rhs; rhs; intro t; rhs; rw [ht t, h n t]; lhs; rw [hn]
  ¬∑ push_cast
    congr
    ext n
    by_cases n_zero : n = 0; simp [n_zero]
    have n_pos : 0 < n := by
      simpa only [n_zero, gt_iff_lt, false_or] using (Nat.eq_zero_or_pos n)
    congr
    rw [(by rw [div_mul]; simp : 1 / (2 * œÄ) = 1 / (2 * œÄ * I) * I), mul_assoc]
    conv => lhs; rhs; rhs; rhs; intro t; rw [mul_comm]; norm_cast
    have := MellinInversion œÉ (f := fun x ‚Ü¶ (Smooth1 SmoothingF Œµ x : ‚ÑÇ)) (x := n / X)
      ?_ ?_ ?_ ?_
    ¬∑ beta_reduce at this
      dsimp [MellinInverseTransform, VerticalIntegral] at this
      rw [‚Üê MellinTransform_eq, this]
    ¬∑ exact div_pos (by exact_mod_cast n_pos) (by linarith : 0 < X)
    ¬∑ apply Smooth1MellinConvergent diffSmoothingF suppSmoothingF ‚ü®Œµpos, Œµ_lt_one‚ü© SmoothingFpos mass_one
      simp only [ofReal_re]
      linarith
    ¬∑ dsimp [VerticalIntegrable]
      rw [‚Üê MellinTransform_eq]
      apply SmoothedChebyshevDirichlet_aux_integrable diffSmoothingF SmoothingFpos
        suppSmoothingF mass_one Œµpos Œµ_lt_one œÉ_gt œÉ_le
    ¬∑ refine ContinuousAt.comp (g := ofReal) RCLike.continuous_ofReal.continuousAt ?_
      exact Smooth1ContinuousAt diffSmoothingF SmoothingFpos suppSmoothingF
        Œµpos (by positivity)
/-%%
\begin{proof}\leanok
\uses{SmoothedChebyshev, MellinInversion, LogDerivativeDirichlet, Smooth1LeOne, MellinOfSmooth1b,
SmoothedChebyshevDirichlet_aux_integrable,
Smooth1ContinuousAt, SmoothedChebyshevDirichlet_aux_tsum_integral}
We have that
$$\psi_{\epsilon}(X) = \frac{1}{2\pi i}\int_{(2)}\sum_{n=1}^\infty \frac{\Lambda(n)}{n^s}
\mathcal{M}(\widetilde{1_{\epsilon}})(s)
X^{s}ds.$$
We have enough decay (thanks to quadratic decay of $\mathcal{M}(\widetilde{1_{\epsilon}})$) to
justify the interchange of summation and integration. We then get
$$\psi_{\epsilon}(X) =
\sum_{n=1}^\infty \Lambda(n)\frac{1}{2\pi i}\int_{(2)}
\mathcal{M}(\widetilde{1_{\epsilon}})(s)
(n/X)^{-s}
ds
$$
and apply the Mellin inversion formula (Theorem \ref{MellinInversion}).
\end{proof}
%%-/

/-%%
\begin{definition}\label{ChebyshevPsi}\lean{ChebyshevPsi}\leanok
The Chebyshev Psi function is defined as
$$
\psi(x) := \sum_{n \le x} \Lambda(n),
$$
where $\Lambda(n)$ is the von Mangoldt function.
\end{definition}
%%-/
noncomputable def ChebyshevPsi (x : ‚Ñù) : ‚Ñù := (Finset.range (Nat.floor (x + 1))).sum ArithmeticFunction.vonMangoldt

-- **Tests with AlphaProof**
theorem extracted_2
    (F : ‚Ñù ‚Üí ‚Ñù)
    (FbddAbove : ‚àÄ x, F x ‚â§ 1)
    (Fnonneg : ‚àÄ x, F x ‚â• 0)
    (FzeroAfter : ‚àÉ (c‚ÇÅ : ‚Ñù) (_ : c‚ÇÅ > 0), ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ) (_ : Œµ < 1),
      ‚àÄ X > (1 : ‚Ñù), ‚àÄ (n : ‚Ñï), n ‚â• (1 + c‚ÇÅ * Œµ) * X ‚Üí F (n / X) = 0)
    (Fone : ‚àÉ (c‚ÇÇ : ‚Ñù) (_ : c‚ÇÇ > 0) (_ : c‚ÇÇ < 1), ‚àÄ (Œµ : ‚Ñù) (_ : 0 < Œµ) (_ : Œµ < 1),
      ‚àÄ X > (1 : ‚Ñù), ‚àÄ (n : ‚Ñï), 0 < n ‚Üí n ‚â§ (1 - c‚ÇÇ * Œµ) * X ‚Üí F (n / X) = 1)
     :
    ‚àÉ (C : ‚Ñù) (_ : 3 < C), ‚àÄ (X : ‚Ñù) (_ : C < X) (Œµ : ‚Ñù) (_ : 0 < Œµ) (_ : Œµ < 1),
    ‚Äñ(‚àë' (n : ‚Ñï), ArithmeticFunction.vonMangoldt n * F (‚Üën / X)) - ChebyshevPsi X‚Äñ ‚â§ C * Œµ * X * Real.log X := by

  sorry


theorem extracted_1 {Smooth1 : (‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù} (SmoothingF : ‚Ñù ‚Üí ‚Ñù)
    (c‚ÇÅ : ‚Ñù) (c‚ÇÅ_pos : 0 < c‚ÇÅ)
    (hc‚ÇÅ : ‚àÄ (Œµ x : ‚Ñù), 0 < Œµ ‚Üí 0 < x ‚Üí x ‚â§ 1 - c‚ÇÅ * Œµ ‚Üí Smooth1 SmoothingF Œµ x = 1) (c‚ÇÇ : ‚Ñù) (c‚ÇÇ_pos : 0 < c‚ÇÇ)
    (hc‚ÇÇ : ‚àÄ (Œµ x : ‚Ñù), Œµ ‚àà Ioo 0 1 ‚Üí 1 + c‚ÇÇ * Œµ ‚â§ x ‚Üí Smooth1 SmoothingF Œµ x = 0) (C_gt' : 3 < c‚ÇÅ + c‚ÇÇ + 3) (C : ‚Ñù)
    (C_eq : C = c‚ÇÅ + c‚ÇÇ + 3) (C_gt : 3 < C) (X : ‚Ñù) (X_ge_C : C < X)
    (Œµ : ‚Ñù) (Œµpos : 0 < Œµ) (Œµ_lt_one : Œµ < 1)
    (this_1 : 0 < X) (this : X ‚â† 0) (n_on_X_pos : ‚àÄ {n : ‚Ñï}, 0 < n ‚Üí 0 < ‚Üën / X)
    (smooth1BddAbove : ‚àÄ (n : ‚Ñï), 0 < n ‚Üí Smooth1 SmoothingF Œµ (‚Üën / X) ‚â§ 1)
    (smooth1BddBelow : ‚àÄ (n : ‚Ñï), 0 < n ‚Üí Smooth1 SmoothingF Œµ (‚Üën / X) ‚â• 0)
    (smoothIs1 : ‚àÄ (n : ‚Ñï), 0 < n ‚Üí ‚Üën ‚â§ X * (1 - c‚ÇÅ * Œµ) ‚Üí Smooth1 SmoothingF Œµ (‚Üën / X) = 1)
    (smoothIs0 : ‚àÄ (n : ‚Ñï), 1 + c‚ÇÇ * Œµ ‚â§ ‚Üën / X ‚Üí Smooth1 SmoothingF Œµ (‚Üën / X) = 0) :
  ‚Äñ(‚Üë((‚àë' (n : ‚Ñï), ArithmeticFunction.vonMangoldt n * Smooth1 SmoothingF Œµ (‚Üën / X))) : ‚ÑÇ) -
        ‚Üë((Finset.range ‚åäX + 1‚åã‚Çä).sum ‚áëArithmeticFunction.vonMangoldt)‚Äñ ‚â§
    C * Œµ * X * Real.log X := by
  sorry


-- **End Test**

/-%%
The smoothed Chebyshev function is close to the actual Chebyshev function.
\begin{theorem}[SmoothedChebyshevClose]\label{SmoothedChebyshevClose}\lean{SmoothedChebyshevClose}\leanok
We have that
$$\psi_{\epsilon}(X) = \psi(X) + O(\epsilon X \log X).$$
\end{theorem}
%%-/
lemma SmoothedChebyshevClose {SmoothingF : ‚Ñù ‚Üí ‚Ñù}
    (diffSmoothingF : ContDiff ‚Ñù 1 SmoothingF)
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2) (SmoothingFnonneg : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
    (mass_one : ‚à´ x in Ioi 0, SmoothingF x / x = 1) (X : ‚Ñù) :
    ‚àÉ (C : ‚Ñù) (_ : 3 < C), ‚àÄ (X : ‚Ñù) (_ : C < X) (Œµ : ‚Ñù) (_ : 0 < Œµ) (_ : Œµ < 1),
    ‚ÄñSmoothedChebyshev SmoothingF Œµ X - ChebyshevPsi X‚Äñ ‚â§ C * Œµ * X * Real.log X := by

  have vonManBnd (n : ‚Ñï) : ArithmeticFunction.vonMangoldt n ‚â§ Real.log n :=
    ArithmeticFunction.vonMangoldt_le_log

  -- have : ‚àÉ c, 0 < c ‚àß
  --   ‚àÄ (Œµ x : ‚Ñù), 0 < Œµ ‚Üí 0 < x ‚Üí x ‚â§ 1 - c * Œµ ‚Üí Smooth1 SmoothingF Œµ x = 1 := Smooth1Properties_below suppSmoothingF mass_one
  obtain ‚ü®c‚ÇÅ, c‚ÇÅ_pos, hc‚ÇÅ‚ü© := Smooth1Properties_below suppSmoothingF mass_one

  -- have : ‚àÉ c, 0 < c ‚àß
  --   ‚àÄ (Œµ x : ‚Ñù), Œµ ‚àà Ioo 0 1 ‚Üí 1 + c * Œµ ‚â§ x ‚Üí Smooth1 SmoothingF Œµ x = 0 := Smooth1Properties_above suppSmoothingF
  obtain ‚ü®c‚ÇÇ, c‚ÇÇ_pos, hc‚ÇÇ‚ü© := Smooth1Properties_above suppSmoothingF

  let C : ‚Ñù := c‚ÇÅ + c‚ÇÇ + 3
  have C_eq : C = c‚ÇÅ + c‚ÇÇ + 3 := rfl
  have C_gt' : 3 < c‚ÇÅ + c‚ÇÇ + 3 := by linarith
  have C_gt : 3 < C := C_gt'

  clear_value C

  refine ‚ü®C, C_gt, fun X X_ge_C Œµ Œµpos Œµ_lt_one ‚Ü¶ ?_‚ü©
  unfold ChebyshevPsi

  have X_gt_zero : (0 : ‚Ñù) < X := by linarith

  have X_ne_zero : X ‚â† 0 := by linarith

  have n_on_X_pos {n : ‚Ñï} (npos : 0 < n) :
      0 < n / X := by
    have : (0 : ‚Ñù) < n := by exact_mod_cast npos
    positivity

  have smooth1BddAbove (n : ‚Ñï) (npos : 0 < n) :
      Smooth1 SmoothingF Œµ (n / X) ‚â§ 1 :=
    Smooth1LeOne SmoothingFnonneg mass_one Œµpos (n_on_X_pos npos)

  have smooth1BddBelow (n : ‚Ñï) (npos : 0 < n) :
      Smooth1 SmoothingF Œµ (n / X) ‚â• 0 :=
    Smooth1Nonneg SmoothingFnonneg (n_on_X_pos npos) Œµpos

  have smoothIs1 (n : ‚Ñï) (npos : 0 < n) (n_le : n ‚â§ X * (1 - c‚ÇÅ * Œµ)) :
      Smooth1 SmoothingF Œµ (‚Üën / X) = 1 := by
    apply hc‚ÇÅ (Œµ := Œµ) (n / X) Œµpos (n_on_X_pos npos)
    (expose_names; exact (div_le_iff‚ÇÄ' sorry).mpr n_le)

  have smoothIs0 (n : ‚Ñï) (n_le : (1 + c‚ÇÇ * Œµ) ‚â§ n / X) :=
    hc‚ÇÇ (Œµ := Œµ) (n / X) ‚ü®Œµpos, Œµ_lt_one‚ü© n_le

  rw [SmoothedChebyshevDirichlet diffSmoothingF SmoothingFnonneg suppSmoothingF
    mass_one (by linarith) Œµpos Œµ_lt_one]

  convert extracted_1 SmoothingF c‚ÇÅ c‚ÇÅ_pos hc‚ÇÅ c‚ÇÇ c‚ÇÇ_pos hc‚ÇÇ C_gt' C C_eq C_gt X X_ge_C Œµ Œµpos Œµ_lt_one
    X_gt_zero X_ne_zero n_on_X_pos smooth1BddAbove smooth1BddBelow smoothIs1 smoothIs0


  -- have := calc
  --   ‚Äñ((‚àë' (n : ‚Ñï), ArithmeticFunction.vonMangoldt n * Smooth1 SmoothingF Œµ (n / X)) : ‚ÑÇ)
  --     - ((Finset.range ‚åäX + 1‚åã‚Çä).sum ArithmeticFunction.vonMangoldt)‚Äñ
  --         ‚â§ C * Œµ * X * Real.log X := ?_

--  sorry
#exit


  sorry

#exit

  --exact this

/-%%
\begin{proof}
\uses{SmoothedChebyshevDirichlet, Smooth1Properties_above,
Smooth1Properties_below,
Smooth1Nonneg,
Smooth1LeOne,
ChebyshevPsi}
Take the difference. By Lemma \ref{Smooth1Properties_above} and \ref{Smooth1Properties_below},
the sums agree except when $1-c \epsilon \leq n/X \leq 1+c \epsilon$. This is an interval of
length $\ll \epsilon X$, and the summands are bounded by $\Lambda(n) \ll \log X$.

%[No longer relevant, as we will do better than any power of log savings...: This is not enough,
%as it loses a log! (Which is fine if our target is the strong PNT, with
%exp-root-log savings, but not here with the ``softer'' approach.) So we will need something like
%the Selberg sieve (already in Mathlib? Or close?) to conclude that the number of primes in this
%interval is $\ll \epsilon X / \log X + 1$.
%(The number of prime powers is $\ll X^{1/2}$.)
%And multiplying that by $\Lambda (n) \ll \log X$ gives the desired bound.]
\end{proof}
%%-/

/-%%
Returning to the definition of $\psi_{\epsilon}$, fix a large $T$ to be chosen later, and pull
contours (via rectangles!) to go
from $2$ up to $2+iT$, then over to $1+iT$, and up from there to $1+i\infty$ (and symmetrically
in the lower half plane).  The
rectangles involved are all where the integrand is holomorphic, so there is no change.
We will do this in several stages
%%-/

theorem SmoothedChebyshevPull1_aux_integrable {SmoothingF : ‚Ñù ‚Üí ‚Ñù} {Œµ : ‚Ñù} (Œµ_pos : 0 < Œµ) (X : ‚Ñù) {œÉ‚ÇÄ : ‚Ñù} (œÉ‚ÇÄ_pos : 0 < œÉ‚ÇÄ)
  (holoOn : HolomorphicOn (SmoothedChebyshevIntegrand SmoothingF Œµ X) (Icc œÉ‚ÇÄ 2 √ó‚ÑÇ univ \ {1}))
  (suppSmoothingF : support SmoothingF ‚äÜ Icc (1 / 2) 2) (SmoothingFnonneg : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
  (mass_one : ‚à´ (x : ‚Ñù) in Ioi 0, SmoothingF x / x = 1) :
  Integrable (fun (t : ‚Ñù) ‚Ü¶ SmoothedChebyshevIntegrand SmoothingF Œµ X (2 + (t : ‚ÑÇ) * I)) volume := by
  sorry

/-%%
\begin{theorem}[SmoothedChebyshevPull1]\label{SmoothedChebyshevPull1}\lean{SmoothedChebyshevPull1}\leanok
We have that
$$\psi_{\epsilon}(X) =
\mathcal{M}(\widetilde{1_{\epsilon}})(1)
X^{1} +
 \frac{1}{2\pi i}\int_{\text{curve}}\frac{-\zeta'(s)}{\zeta(s)}
\mathcal{M}(\widetilde{1_{\epsilon}})(s)
X^{s}ds.$$
\end{theorem}
%%-/
theorem SmoothedChebyshevPull1 {SmoothingF : ‚Ñù ‚Üí ‚Ñù} {Œµ : ‚Ñù} (Œµ_pos: 0 < Œµ) (X : ‚Ñù) {T : ‚Ñù} (T_pos : 0 < T) {œÉ‚ÇÄ : ‚Ñù}
    (œÉ‚ÇÄ_pos : 0 < œÉ‚ÇÄ)
    (holoOn : HolomorphicOn (SmoothedChebyshevIntegrand SmoothingF Œµ X) ((Icc œÉ‚ÇÄ 2)√ó‚ÑÇ (univ : Set ‚Ñù) \ {1}))
    (suppSmoothingF : Function.support SmoothingF ‚äÜ Icc (1 / 2) 2) (SmoothingFnonneg : ‚àÄ x > 0, 0 ‚â§ SmoothingF x)
    (mass_one : ‚à´ x in Ioi 0, SmoothingF x / x = 1) :
    SmoothedChebyshev SmoothingF Œµ X =
    (1 / (2 * œÄ * I)) * (I * (‚à´ t : ‚Ñù in Iic (-T),
      SmoothedChebyshevIntegrand SmoothingF Œµ X ((1 + (Real.log X)‚Åª¬π) + t * I)) -
    (‚à´ s : ‚Ñù in Icc œÉ‚ÇÄ (1 + (Real.log X)‚Åª¬π), SmoothedChebyshevIntegrand SmoothingF Œµ X (s - T * I)) +
    I * (‚à´ t : ‚Ñù in Icc (-T) T, SmoothedChebyshevIntegrand SmoothingF Œµ X (œÉ‚ÇÄ + t * I)) +
    (‚à´ s : ‚Ñù in Icc œÉ‚ÇÄ (1 + (Real.log X)‚Åª¬π), SmoothedChebyshevIntegrand SmoothingF Œµ X (s + T * I)) +
    I * (‚à´ t : ‚Ñù in Ici T,
      SmoothedChebyshevIntegrand SmoothingF Œµ X ((1 + (Real.log X)‚Åª¬π) + t * I)) )
    + ùìú ((Smooth1 SmoothingF Œµ) ¬∑) 1 * X := by
  unfold SmoothedChebyshev
  unfold VerticalIntegral'
  rw [verticalIntegral_split_three (a := -T) (b := T)]

  swap
  sorry
  --exact SmoothedChebyshevPull1_aux_integrable Œµ_pos X œÉ‚ÇÄ_pos holoOn suppSmoothingF SmoothingFnonneg mass_one



    --VerticalIntegral' (SmoothedChebyshevIntegrand SmoothingF Œµ X) 2
  sorry
/-%%
\begin{proof}
\uses{SmoothedChebyshev, RectangleIntegral}
Pull rectangle contours and evaluate the pole at $s=1$.
\end{proof}
%%-/

/-%
\begin{theorem}[ZetaNoZerosOn1Line]\label{ZetaNoZerosOn1Line}
The zeta function does not vanish on the 1-line.
\end{theorem}
This fact is already proved in Stoll's work.
%-/

/-%
Then, since $\zeta$ doesn't vanish on the 1-line, there is a $\delta$ (depending on $T$), so that
the box $[1-\delta,1] \times_{‚ÑÇ} [-T,T]$ is free of zeros of $\zeta$.
\begin{theorem}\label{ZetaNoZerosInBox}
For any $T>0$, there is a $\delta>0$ so that $[1-\delta,1] \times_{‚ÑÇ} [-T,T]$ is free of zeros of
$\zeta$.
\end{theorem}
%-/

/-%
\begin{proof}
\uses{ZetaNoZerosOn1Line}
We have that zeta doesn't vanish on the 1 line and is holomorphic inside the box (except for the
pole at $s=1$). If for a height $T>0$, there was no such $\delta$, then there would be a sequence
of zeros of $\zeta$ approaching the 1 line, and by compactness, we could find a subsequence of
zeros converging to a point on the 1 line. But then $\zeta$ would vanish at that point, a
contradiction. (Worse yet, zeta would then be entirely zero...)
\end{proof}
%-/

/-%
The rectangle with opposite corners $1-\delta - i T$ and $2+iT$ contains a single pole of
$-\zeta'/\zeta$ at $s=1$, and the residue is $1$ (from Theorem \ref{ResidueOfLogDerivative}).
\begin{theorem}\label{ZeroFreeBox}
$-\zeta'/\zeta$ is holomorphic on the box $[1-\delta,2] \times_{‚ÑÇ} [-T,T]$, except a simple pole
with residue $1$ at $s$=1.
\end{theorem}
%-/

/-%
\begin{proof}
\uses{ZetaNoZerosInBox, ResidueOfLogDerivative}
The proof is as described.
\end{proof}
%-/

/-%%
We insert this information in $\psi_{\epsilon}$. We add and subtract the integral over the box
$[1-\delta,2] \times_{‚ÑÇ} [-T,T]$, which we evaluate as follows
\begin{theorem}[ZetaBoxEval]\label{ZetaBoxEval}
The rectangle integral over $[1-\delta,2] \times_{‚ÑÇ} [-T,T]$ of the integrand in
$\psi_{\epsilon}$ is
$$\frac{1}{2\pi i}\int_{\partial([1-\delta,2] \times_{‚ÑÇ} [-T,T])}\frac{-\zeta'(s)}{\zeta(s)}
\mathcal{M}(\widetilde{1_{\epsilon}})(s)
X^{s}ds = \frac{X^{1}}{1}\mathcal{M}(\widetilde{1_{\epsilon}})(1)
= X\left(\mathcal{M}(\psi)\left(\epsilon\right)\right)
= X(1+O(\epsilon))
.$$
\end{theorem}
%%-/

/-%%
\begin{proof}
\uses{RectangleBorder, RectangleIntegral,
MellinOfSmooth1a, MellinOfSmooth1b, MellinOfSmooth1c, MellinOfDeltaSpikeAt1,
SmoothedChebyshevPull1}
Residue calculus / the argument principle.
\end{proof}
%%-/

/-%%
It remains to estimate the contributions from the integrals over the curve $\gamma = \gamma_1 +
\gamma_2 + \gamma_3 + \gamma_4
+\gamma_5,
$
where:
\begin{itemize}
\item $\gamma_1$ is the vertical segment from $1-i\infty$ to $1-iT$,
\item $\gamma_2$ is the horizontal segment from $1-iT$ to $1-\delta-iT$,
\item $\gamma_3$ is the vertical segment from $1-\delta-iT$ to $1-\delta+iT$,
\item $\gamma_4$ is the horizontal segment from $1-\delta+iT$ to $1+iT$, and
\item $\gamma_5$ is the vertical segment from $1+iT$ to $1+i\infty$.
\end{itemize}

%%-/

/-%%
\section{MediumPNT}

\begin{theorem}[MediumPNT]\label{MediumPNT}  We have
$$ \sum_{n \leq x} \Lambda(n) = x + O(x \exp(-c(\log x)^{1/10})).$$
\end{theorem}
%%-/
/-- *** Prime Number Theorem (Medium Strength) *** The `ChebyshevPsi` function is asymptotic to `x`. -/
theorem MediumPNT : ‚àÉ (c : ‚Ñù) (_ : 0 < c),
    (ChebyshevPsi - id) =O[atTop] (fun (x : ‚Ñù) ‚Ü¶ x * Real.exp (-c * (Real.log x) ^ ((1 : ‚Ñù) / 10))) := by
  let c : ‚Ñù := sorry
  have cpos : 0 < c := sorry
  refine ‚ü®c, cpos, ?_‚ü©
  rw [Asymptotics.isBigO_iff]
  let C : ‚Ñù := sorry
  refine ‚ü®C, ?_‚ü©
  rw [Filter.eventually_atTop]
  let X‚ÇÄ : ‚Ñù := sorry
  refine ‚ü®X‚ÇÄ, ?_‚ü©
  intro X X_ge_X‚ÇÄ

  sorry
/-%%
\begin{proof}
\uses{ChebyshevPsi, SmoothedChebyshevClose, LogDerivZetaBndAlt, ZetaBoxEval}
  Evaluate the integrals.
\end{proof}
%%-/
