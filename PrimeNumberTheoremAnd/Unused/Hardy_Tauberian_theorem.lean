/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7236be66-7e7b-4874-9d1f-4042dc2b1932

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized Hardy's Tauberian Theorem.
The main result is `hardy_tauberian`, which states that if the arithmetic means of the partial sums of a series `u` converge to `S`, and the terms satisfy `|u n| ≤ A / n`, then the partial sums themselves converge to `S`.
The proof follows the method of delayed arithmetic means as outlined in Wheedon-Zygmund.
Key lemmas include:
- `hardy_sigma_delayed_eq`: Expresses delayed means in terms of arithmetic means.
- `hardy_sigma_delayed_tendsto`: Shows delayed means converge if arithmetic means converge and `n/k` is bounded.
- `hardy_sigma_delayed_bound`: Bounds the difference between delayed means and partial sums.
- `hardy_diff_bound`: Shows the difference is eventually small for a specific choice of `k`.
- `tendsto_of_approx_aux`: A general lemma for proving convergence via approximation.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The partial sum s_n of the series u_n.
-/
def hardy_s (u : ℕ → ℝ) (n : ℕ) : ℝ := ∑ i ∈ Finset.range (n + 1), u i

/-
The arithmetic mean sigma_n of the partial sums s_n.
-/
def hardy_sigma (u : ℕ → ℝ) (n : ℕ) : ℝ := (∑ i ∈ Finset.range (n + 1), hardy_s u i) / (n + 1)

/-
The delayed arithmetic mean sigma_{n,k}.
-/
def hardy_sigma_delayed (u : ℕ → ℝ) (n k : ℕ) : ℝ := (∑ i ∈ Finset.Ioc n (n + k), hardy_s u i) / k

/-
Express delayed arithmetic means in terms of arithmetic means. Note: Corrected a likely typo in the source text from n/k to (n+1)/k.
-/
theorem hardy_sigma_delayed_eq (u : ℕ → ℝ) (n k : ℕ) (hk : k ≠ 0) :
    hardy_sigma_delayed u n k =
    ((n + k + 1 : ℝ) / k) * hardy_sigma u (n + k) - ((n + 1 : ℝ) / k) * hardy_sigma u n := by
  field_simp;
  unfold hardy_sigma_delayed hardy_sigma;
  rw [ div_mul_cancel₀ _ ( by positivity ), mul_div ];
  rw [ eq_sub_iff_add_eq, eq_div_iff ] <;> norm_cast ; norm_num;
  rw [ mul_comm, ← Finset.sum_range_add_sum_Ico _ ( by linarith : n + 1 ≤ n + k + 1 ) ];
  field_simp;
  rw [ add_comm, Nat.Ico_succ_right ];
  rw [ Nat.Icc_succ_left ]

/-
If the arithmetic means converge to S, and n/k_n is bounded, then the delayed arithmetic means also converge to S.
-/
theorem hardy_sigma_delayed_tendsto (u : ℕ → ℝ) (S : ℝ) (k : ℕ → ℕ)
    (h_sigma : Filter.Tendsto (hardy_sigma u) Filter.atTop (nhds S))
    (h_bounded : Filter.IsBoundedUnder (· ≤ ·) Filter.atTop (fun (n : ℕ) => (n : ℝ) / k n))
    (hk_pos : ∀ n, 0 < k n) :
    Filter.Tendsto (fun n => hardy_sigma_delayed u n (k n)) Filter.atTop (nhds S) := by
  -- Since $\lim_{n\to\infty} \frac{n}{k_n}$ exists and is finite, we have $\lim_{n\to\infty} \frac{1}{k_n} = 0$.
  have h_lim_k_n_inv : Filter.Tendsto (fun n => (1 : ℝ) / (k n)) Filter.atTop (nhds 0) := by
    -- Since $k_n$ is bounded above, there exists some $M > 0$ such that $k_n \geq \frac{n}{M}$ for all $n$.
    obtain ⟨M, hM⟩ : ∃ M > 0, ∀ n, (k n : ℝ) ≥ n / M := by
      obtain ⟨ M, hM ⟩ := h_bounded;
      -- Since $k_n$ is bounded above, there exists some $N$ such that for all $n \geq N$, $n / k_n \leq M$.
      obtain ⟨N, hN⟩ : ∃ N : ℕ, ∀ n ≥ N, (n : ℝ) / (k n : ℝ) ≤ M := by
        aesop;
      -- Since $k_n$ is bounded above, there exists some $M > 0$ such that for all $n \geq N$, $k_n \geq \frac{n}{M}$.
      obtain ⟨M', hM'⟩ : ∃ M' > 0, ∀ n ≥ N, (k n : ℝ) ≥ n / M' := by
        exact ⟨ Max.max M 1, by positivity, fun n hn => by rw [ ge_iff_le ] ; rw [ div_le_iff₀ ] <;> nlinarith [ hN n hn, le_max_left M 1, le_max_right M 1, show ( k n : ℝ ) ≥ 1 from mod_cast hk_pos n, div_mul_cancel₀ ( n : ℝ ) ( show ( k n : ℝ ) ≠ 0 from mod_cast ne_of_gt ( hk_pos n ) ) ] ⟩;
      -- Since $k_n$ is bounded above, there exists some $M > 0$ such that for all $n < N$, $k_n \geq \frac{n}{M}$.
      obtain ⟨M'', hM''⟩ : ∃ M'' > 0, ∀ n < N, (k n : ℝ) ≥ n / M'' := by
        field_simp;
        exact ⟨ N + 1, by positivity, fun n hn => by rw [ div_le_iff₀ ] <;> nlinarith [ show ( n : ℝ ) + 1 ≤ N by norm_cast, show ( k n : ℝ ) ≥ 1 by exact_mod_cast hk_pos n ] ⟩;
      exact ⟨ Max.max M' M'', lt_max_of_lt_left hM'.1, fun n => if hn : n < N then le_trans ( div_le_div_of_nonneg_left ( Nat.cast_nonneg _ ) ( by linarith [ hM''.1 ] ) ( le_max_right _ _ ) ) ( hM''.2 n hn ) else le_trans ( div_le_div_of_nonneg_left ( Nat.cast_nonneg _ ) ( by linarith [ hM'.1 ] ) ( le_max_left _ _ ) ) ( hM'.2 n ( le_of_not_gt hn ) ) ⟩;
    refine' tendsto_const_nhds.div_atTop _;
    exact Filter.tendsto_atTop_mono hM.2 <| tendsto_natCast_atTop_atTop.atTop_div_const hM.1;
  -- Using the fact that $n / k_n$ is bounded, we can apply the squeeze theorem.
  have h_squeeze : Filter.Tendsto (fun n => ((n + k n + 1 : ℝ) / (k n)) * (hardy_sigma u (n + k n)) - ((n + 1 : ℝ) / (k n)) * (hardy_sigma u n)) Filter.atTop (nhds S) := by
    -- We can split the limit into two parts: the term involving $hardy_sigma u$ and the term involving $1$.
    have h_split : Filter.Tendsto (fun n => (hardy_sigma u (n + k n) - hardy_sigma u n) * (n / (k n) : ℝ)) Filter.atTop (nhds 0) ∧ Filter.Tendsto (fun n => hardy_sigma u (n + k n) + (hardy_sigma u (n + k n) - hardy_sigma u n) * (1 / (k n) : ℝ)) Filter.atTop (nhds S) := by
      constructor;
      · -- Since $hardy_sigma u (n + k n) - hardy_sigma u n$ tends to $0$ as $n$ tends to infinity, and $n / k n$ is bounded, their product tends to $0$.
        have h_prod_zero : Filter.Tendsto (fun n => hardy_sigma u (n + k n) - hardy_sigma u n) Filter.atTop (nhds 0) := by
          simpa using Filter.Tendsto.sub ( h_sigma.comp ( Filter.tendsto_atTop_mono ( fun n => Nat.le_add_right _ _ ) Filter.tendsto_id ) ) h_sigma;
        rw [ Metric.tendsto_nhds ] at *;
        field_simp;
        intro ε hε; rcases h_bounded with ⟨ M, hM ⟩ ; rcases h_prod_zero ( ε / ( Max.max M 1 + 1 ) ) ( by positivity ) with h; filter_upwards [ h, hM ] with n hn hn'; simp_all +decide [ abs_div, abs_mul, div_lt_iff₀ ] ;
        rw [ lt_div_iff₀ ( by positivity ) ] at hn;
        rw [ div_le_iff₀ ( Nat.cast_pos.mpr ( hk_pos n ) ) ] at hn';
        nlinarith [ abs_nonneg ( hardy_sigma u ( n + k n ) - hardy_sigma u n ), show ( k n : ℝ ) ≥ 1 by exact_mod_cast hk_pos n, le_max_left M 1, le_max_right M 1, mul_le_mul_of_nonneg_left ( le_max_left M 1 ) ( show ( 0 : ℝ ) ≤ k n by positivity ), mul_le_mul_of_nonneg_left ( le_max_right M 1 ) ( show ( 0 : ℝ ) ≤ k n by positivity ) ];
      · simpa using Filter.Tendsto.add ( h_sigma.comp ( Filter.tendsto_atTop_mono ( fun n => Nat.le_add_right _ _ ) Filter.tendsto_id ) ) ( Filter.Tendsto.mul ( Filter.Tendsto.sub ( h_sigma.comp ( Filter.tendsto_atTop_mono ( fun n => Nat.le_add_right _ _ ) Filter.tendsto_id ) ) h_sigma ) h_lim_k_n_inv );
    convert h_split.2.add h_split.1 using 2 <;> ring;
    simpa [ ne_of_gt ( hk_pos _ ) ] using by ring;
  exact h_squeeze.congr fun n => by rw [ hardy_sigma_delayed_eq _ _ _ ( ne_of_gt ( hk_pos n ) ) ] ;

/-
Identity for the difference between delayed arithmetic mean and partial sum.
-/
theorem hardy_sigma_delayed_sub_s_eq (u : ℕ → ℝ) (n k : ℕ) (hk : k ≠ 0) :
    hardy_sigma_delayed u n k - hardy_s u n =
    (1 / k) * ∑ j ∈ Finset.Icc 1 k, (k - j + 1 : ℝ) * u (n + j) := by
  field_simp;
  -- By definition of $hardy_sigma_delayed$, we can rewrite the left-hand side of the equation.
  have h_def : hardy_sigma_delayed u n k - hardy_s u n = (1 / k : ℝ) * ∑ j ∈ Finset.Icc 1 k, (hardy_s u (n + j) - hardy_s u n) := by
    unfold hardy_sigma_delayed hardy_s; norm_num [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] ; ring;
    rw [ show ( Finset.Ioc n ( n + k ) ) = Finset.image ( fun x => n + x ) ( Finset.Ioc 0 k ) from ?_, Finset.sum_image ] <;> norm_num ; ring;
    norm_num [ hk ];
  -- By definition of $hardy_s$, we can rewrite the sum inside the parentheses.
  have h_sum : ∑ j ∈ Finset.Icc 1 k, (hardy_s u (n + j) - hardy_s u n) = ∑ j ∈ Finset.Icc 1 k, ∑ m ∈ Finset.Icc 1 j, u (n + m) := by
    refine' Finset.sum_congr rfl fun j hj => _;
    erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ, hardy_s ];
    rw [ Finset.sum_range_add ] ; ring;
  -- By interchanging the order of summation, we can rewrite the double sum.
  have h_interchange : ∑ j ∈ Finset.Icc 1 k, ∑ m ∈ Finset.Icc 1 j, u (n + m) = ∑ m ∈ Finset.Icc 1 k, ∑ j ∈ Finset.Icc m k, u (n + m) := by
    erw [ Finset.sum_Ico_Ico_comm ];
    rfl;
  simp_all +decide [ Finset.sum_mul _ _ _ ];
  rw [ inv_mul_eq_div, div_mul_cancel₀ _ ( by positivity ), Finset.sum_congr rfl ] ; intros ; rw [ Nat.cast_sub ] <;> push_cast <;> linarith [ Finset.mem_Icc.mp ‹_› ] ;

/-
Bound on the difference between delayed arithmetic mean and partial sum.
-/
theorem hardy_sigma_delayed_bound (u : ℕ → ℝ) (n k : ℕ) (A : ℝ) (hk : k ≠ 0)
    (h_u_bound : ∀ m, n < m → m ≤ n + k → |u m| ≤ A / m) :
    |hardy_sigma_delayed u n k - hardy_s u n| ≤ (k : ℝ) / (n + 1) * A := by
  -- Applying the bound $|u_{n+j}| \leq A / (n+j)$ to each term in the sum.
  have h_sum_bound : ∑ j ∈ Finset.Icc 1 k, (k - j + 1 : ℝ) * |u (n + j)| ≤ ∑ j ∈ Finset.Icc 1 k, (k - j + 1 : ℝ) * (A / (n + j : ℝ)) := by
    exact Finset.sum_le_sum fun x hx => mul_le_mul_of_nonneg_left ( mod_cast h_u_bound _ ( by linarith [ Finset.mem_Icc.mp hx ] ) ( by linarith [ Finset.mem_Icc.mp hx ] ) ) ( by linarith [ show ( x : ℝ ) ≤ k by norm_cast; linarith [ Finset.mem_Icc.mp hx ] ] );
  -- Applying the bound $|(k - j + 1) u_{n+j}| \leq k |u_{n+j}|$ to each term in the sum.
  have h_sum_bound' : ∑ j ∈ Finset.Icc 1 k, (k - j + 1 : ℝ) * |u (n + j)| ≤ ∑ j ∈ Finset.Icc 1 k, k * (A / (n + 1 : ℝ)) := by
    refine le_trans h_sum_bound <| Finset.sum_le_sum fun x hx => mul_le_mul ?_ ?_ ?_ ?_;
    · linarith [ show ( x : ℝ ) ≥ 1 by norm_cast; linarith [ Finset.mem_Icc.mp hx ] ];
    · field_simp;
      rw [ div_le_iff₀ ] <;> nlinarith only [ show ( x : ℝ ) ≥ 1 by norm_cast; linarith [ Finset.mem_Icc.mp hx ], show ( n : ℝ ) ≥ 0 by positivity, show ( A : ℝ ) ≥ 0 by exact le_of_not_gt fun h => by have := h_u_bound ( n + 1 ) ( by linarith [ Finset.mem_Icc.mp hx ] ) ( by linarith [ Finset.mem_Icc.mp hx ] ) ; rw [ le_div_iff₀ ] at this <;> norm_num at * <;> nlinarith [ abs_nonneg ( u ( n + 1 ) ) ] ];
    · exact le_trans ( abs_nonneg _ ) ( h_u_bound ( n + x ) ( by linarith [ Finset.mem_Icc.mp hx ] ) ( by linarith [ Finset.mem_Icc.mp hx ] ) ) |> le_trans <| by norm_num;
    · positivity;
  -- Applying the bound $|(k - j + 1) u_{n+j}| \leq k |u_{n+j}|$ to each term in the sum and using the triangle inequality.
  have h_triangle : |hardy_sigma_delayed u n k - hardy_s u n| ≤ (1 / k : ℝ) * ∑ j ∈ Finset.Icc 1 k, (k - j + 1 : ℝ) * |u (n + j)| := by
    rw [ hardy_sigma_delayed_sub_s_eq u n k hk ];
    rw [ abs_mul, abs_of_nonneg ( by positivity ) ];
    exact mul_le_mul_of_nonneg_left ( le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun _ _ => by rw [ abs_mul, abs_of_nonneg ] ; linarith [ show ( ↑‹ℕ› : ℝ ) ≤ k by norm_cast; linarith [ Finset.mem_Icc.mp ‹_› ] ] ) ) ( by positivity );
  convert h_triangle.trans ( mul_le_mul_of_nonneg_left h_sum_bound' <| by positivity ) using 1 ; norm_num ; ring;
  simp +decide [ sq, mul_right_comm, hk ]

/-
Properties of k_n = floor(epsilon * n): eventually positive and n/k_n is bounded.
-/
lemma k_n_properties (ε : ℝ) (hε : 0 < ε) :
    Filter.IsBoundedUnder (· ≤ ·) Filter.atTop (fun (n : ℕ) => (n : ℝ) / Nat.floor (ε * n)) ∧
    ∀ᶠ n in Filter.atTop, 0 < Nat.floor (ε * n) := by
  constructor <;> norm_num [ Filter.IsBoundedUnder, Filter.IsBounded ];
  · use 2 / ε;
    exact ⟨ ⌈ε⁻¹ * 2⌉₊ + 1, fun n hn => by rw [ div_le_div_iff₀ ] <;> nlinarith [ Nat.le_ceil ( ε⁻¹ * 2 ), Nat.lt_of_ceil_lt hn, Nat.floor_le ( show 0 ≤ ε * ↑n by positivity ), Nat.lt_floor_add_one ( ε * ↑n ), mul_inv_cancel₀ ( ne_of_gt hε ), mul_div_cancel₀ ( 2 : ℝ ) hε.ne' ] ⟩;
  · exact ⟨ 1 / ε + 1, fun x hx => Nat.floor_pos.2 <| by nlinarith [ mul_div_cancel₀ 1 hε.ne' ] ⟩

/-
Helper sequence k_n for the proof, defined as max(1, floor(epsilon * n)).
-/
def hardy_k (ε : ℝ) (n : ℕ) : ℕ := max 1 (Nat.floor (ε * n))

/-
Eventually, the difference between delayed sigma and s is bounded by epsilon * A.
-/
lemma hardy_diff_bound (u : ℕ → ℝ) (A : ℝ) (ε : ℝ) (hε : 0 < ε)
    (h_bound : ∀ n ≥ 1, |u n| ≤ A / n) :
    ∀ᶠ n in Filter.atTop, |hardy_sigma_delayed u n (hardy_k ε n) - hardy_s u n| ≤ ε * A := by
  -- Apply `hardy_sigma_delayed_bound` with `k = hardy_k ε n`.
  have h_bound : ∀ᶠ n in Filter.atTop, |hardy_sigma_delayed u n (hardy_k ε n) - hardy_s u n| ≤ (hardy_k ε n : ℝ) / (n + 1) * A := by
    field_simp;
    -- By the bound on the difference between the delayed arithmetic mean and the partial sum, we have:
    have h_diff_bound : ∀ n ≥ 1, |hardy_sigma_delayed u n (hardy_k ε n) - hardy_s u n| ≤ (hardy_k ε n : ℝ) / (n + 1) * A := by
      intros n hn
      apply hardy_sigma_delayed_bound u n (hardy_k ε n) A (by
      exact ne_of_gt ( lt_max_of_lt_left zero_lt_one )) (by
      exact fun m hm₁ hm₂ => h_bound m ( by linarith ));
    filter_upwards [ Filter.eventually_ge_atTop 1 ] with n hn using by have := h_diff_bound n hn; rw [ div_mul_eq_mul_div, le_div_iff₀ ] at this <;> linarith;;
  -- Since `hardy_k ε n` is eventually equal to `Nat.floor (ε * n)`, we can simplify the expression.
  have h_floor : ∀ᶠ n in Filter.atTop, (hardy_k ε n : ℝ) ≤ ε * n := by
    simp [hardy_k];
    exact ⟨ ⌈ε⁻¹⌉₊ + 1, fun n hn => ⟨ by nlinarith [ Nat.le_ceil ( ε⁻¹ ), mul_inv_cancel₀ ( ne_of_gt hε ), ( by norm_cast : ( ⌈ε⁻¹⌉₊ : ℝ ) + 1 ≤ n ) ], Nat.floor_le ( by positivity ) ⟩ ⟩;
  filter_upwards [ h_bound, h_floor ] with n hn hn' using le_trans hn ( by rw [ div_mul_eq_mul_div, div_le_iff₀ ] <;> nlinarith [ show ( 0 :ℝ ) ≤ ε * A by exact mul_nonneg hε.le ( show 0 ≤ A by have := ‹∀ n ≥ 1, |u n| ≤ A / ( n :ℝ ) › 1 le_rfl; norm_num at this; linarith [ abs_le.mp this ] ) ] )

/-
If a sequence can be approximated arbitrarily well (up to a constant factor) by sequences converging to S, then it converges to S.
-/
lemma tendsto_of_approx_aux {u : ℕ → ℝ} {S : ℝ} {C : ℝ} (hC : 0 ≤ C)
    (h : ∀ ε > 0, ∃ (v : ℕ → ℝ), Filter.Tendsto v Filter.atTop (nhds S) ∧ ∀ᶠ n in Filter.atTop, |u n - v n| ≤ ε * C) :
    Filter.Tendsto u Filter.atTop (nhds S) := by
  refine' Metric.tendsto_atTop.mpr _;
  intro ε hε;
  rcases h ( ε / 2 / ( Max.max C 1 ) ) ( div_pos ( half_pos hε ) ( by positivity ) ) with ⟨ v, hv₁, hv₂ ⟩;
  rcases Filter.eventually_atTop.mp ( hv₂.and ( hv₁.eventually ( Metric.ball_mem_nhds _ ( half_pos hε ) ) ) ) with ⟨ N, hN ⟩ ; exact ⟨ N, fun n hn => abs_lt.mpr ⟨ by nlinarith [ abs_lt.mp ( hN n hn |>.2 ), abs_le.mp ( hN n hn |>.1 ), le_max_left C 1, le_max_right C 1, mul_div_cancel₀ ( ε / 2 ) ( show ( Max.max C 1 ) ≠ 0 by positivity ) ], by nlinarith [ abs_lt.mp ( hN n hn |>.2 ), abs_le.mp ( hN n hn |>.1 ), le_max_left C 1, le_max_right C 1, mul_div_cancel₀ ( ε / 2 ) ( show ( Max.max C 1 ) ≠ 0 by positivity ) ] ⟩ ⟩

/-
The ratio n / k_n is bounded for our choice of k_n.
-/
lemma hardy_k_ratio_bounded (ε : ℝ) (hε : 0 < ε) :
    Filter.IsBoundedUnder (· ≤ ·) Filter.atTop (fun (n : ℕ) => (n : ℝ) / (hardy_k ε n : ℝ)) := by
  -- We know `hardy_k ε n = max 1 (floor (ε * n))`. Eventually `floor (ε * n) >= 1`, so `hardy_k = floor`.
  have h_eventually_floor : ∀ᶠ n in Filter.atTop, hardy_k ε n = Nat.floor (ε * n) := by
    simp +zetaDelta at *;
    exact ⟨ ⌈ε⁻¹⌉₊ + 1, fun n hn => max_eq_right <| Nat.floor_pos.mpr <| by nlinarith [ Nat.le_ceil ( ε⁻¹ ), show ( n : ℝ ) ≥ ⌈ε⁻¹⌉₊ + 1 by exact_mod_cast hn, mul_inv_cancel₀ hε.ne' ] ⟩;
  -- We already proved `n / floor` is bounded in `k_n_properties`.
  have h_bounded_floor : Filter.IsBoundedUnder (· ≤ ·) Filter.atTop (fun n : ℕ => (n : ℝ) / (Nat.floor (ε * n)) : ℕ → ℝ) := by
    exact k_n_properties ε hε |>.1;
  obtain ⟨ C, hC ⟩ := h_bounded_floor;
  refine' ⟨ Max.max C 1, Filter.eventually_atTop.mpr _ ⟩;
  obtain ⟨ N, hN ⟩ := Filter.eventually_atTop.mp hC; obtain ⟨ M, hM ⟩ := Filter.eventually_atTop.mp h_eventually_floor; use Max.max N M; intros n hn; aesop;

/-
Hardy's Tauberian Theorem: If the arithmetic means of partial sums of a series converge to S, and the terms are O(1/n), then the series converges to S.
-/
theorem hardy_tauberian (u : ℕ → ℝ) (A : ℝ) (S : ℝ)
    (h_conv : Filter.Tendsto (hardy_sigma u) Filter.atTop (nhds S))
    (h_bound : ∀ n ≥ 1, |u n| ≤ A / n) :
    Filter.Tendsto (hardy_s u) Filter.atTop (nhds S) := by
      convert tendsto_of_approx_aux _ _;
      exact |A| + 1;
      · positivity;
      · intro ε hε
        use fun n => hardy_sigma_delayed u n (hardy_k ε n);
        constructor;
        · convert hardy_sigma_delayed_tendsto u S ( fun n => hardy_k ε n ) h_conv _ _ using 1;
          · convert hardy_k_ratio_bounded ε hε using 1;
          · exact fun n => Nat.pos_of_ne_zero ( by unfold hardy_k; aesop );
        · have := hardy_diff_bound u A ε hε h_bound;
          filter_upwards [ this ] with n hn using by rw [ abs_sub_comm ] ; exact le_trans hn ( mul_le_mul_of_nonneg_left ( by cases abs_cases A <;> linarith ) hε.le ) ;

/-
Hardy's Tauberian Theorem: If the arithmetic means of partial sums of a series converge to S, and the terms are O(1/n), then the series converges to S.
-/
theorem hardy_tauberian_theorem (u : ℕ → ℝ) (A : ℝ) (S : ℝ)
    (h_conv : Filter.Tendsto (hardy_sigma u) Filter.atTop (nhds S))
    (h_bound : ∀ n ≥ 1, |u n| ≤ A / n) :
    Filter.Tendsto (hardy_s u) Filter.atTop (nhds S) := by
  have hA : 0 ≤ A := by
    have := h_bound 1 le_rfl
    norm_num at this
    exact le_trans (abs_nonneg _) this
  apply tendsto_of_approx_aux hA
  intro ε hε
  let k := hardy_k ε
  have hk_pos : ∀ n, 0 < k n := fun n => lt_of_lt_of_le zero_lt_one (le_max_left _ _)
  use fun n => hardy_sigma_delayed u n (k n)
  constructor
  · apply hardy_sigma_delayed_tendsto u S k h_conv (hardy_k_ratio_bounded ε hε) hk_pos
  · have := hardy_diff_bound u A ε hε h_bound
    filter_upwards [this] with n hn
    rw [abs_sub_comm]
    exact hn